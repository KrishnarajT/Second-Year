% This is a Basic Assignment Paper but with like Code and stuff allowed in it, there is also url, hyperlinks from contents included. 

\documentclass[11pt]{article}

% Preamble

\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb}
\usepackage{fancyhdr, float, graphicx}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage{fouriernc} % Use the New Century Schoolbook font
\usepackage[nottoc, notlot, notlof]{tocbibind}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{blindtext}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=cyan,
    pdfpagemode=FullScreen,
    }

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Header and Footer
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\textit{\Large{Advanced Data Structures - Assignment 2}}}
%\fancyhead[R]{\textit{something}}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}



% Other Doc Editing
% \parindent 0ex
%\renewcommand{\baselinestretch}{1.5}

\begin{document}

\begin{titlepage}
	\centering

	%---------------------------NAMES-------------------------------

	\huge\textsc{
		MIT World Peace University
	}\\

	\vspace{0.75\baselineskip} % space after Uni Name

	\LARGE{
		Advanced Data Structures\\
		Second Year B. Tech, Semester 4
	}

	\vfill % space after Sub Name

	%--------------------------TITLE-------------------------------

	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
	\rule{\textwidth}{0.6pt}
	\vspace{0.75\baselineskip} % Whitespace above the title



	\huge{\textsc{
			Creation and Traversal of Binary Trees\\
            (Recursive and Non-Recursive)
		}} \\



	\vspace{0.5\baselineskip} % Whitespace below the title
	\rule{\textwidth}{0.6pt}\vspace*{-\baselineskip}\vspace*{2.8pt}
	\rule{\textwidth}{1.6pt}

	\vspace{1\baselineskip} % Whitespace after the title block

	%--------------------------SUBTITLE --------------------------	

	\LARGE\textsc{
		Assignment No. 2
	} % Subtitle or further description
	\vfill

	%--------------------------AUTHOR-------------------------------

	Prepared By
	\vspace{0.5\baselineskip} % Whitespace before the editors

	\Large{
		Krishnaraj Thadesar \\
		Cyber Security and Forensics\\
		Batch A1, PA 20
	}


	\vspace{0.5\baselineskip} % Whitespace below the editor list
	\today

\end{titlepage}

\tableofcontents
\thispagestyle{empty}
\clearpage

\setcounter{page}{1}

\section{Objectives}
\begin{enumerate}
	\item  To study data structure : Tree and Binary Tree
    \item  To study different traversals in Binary Tree
    \item  To study recursive and non-recursive approach of programming
\end{enumerate}

\section{Problem Statement}
\textit{Implement binary tree using C++ and perform following operations: Creation of binary tree and
traversal (recursive and non- recursive)}
\section{Theory}

\subsection{Tree}
\begin{enumerate}
    \item A tree is a non-linear data structure.
    \item A tree is a collection of nodes connected by edges.
    \item A tree is a hierarchical data structure.
    \item A tree is a data structure that simulates a hierarchical tree structure, with a root value and subtrees of children with a parent node, represented as a set of linked nodes.
    \item A tree data structure can be defined recursively (locally) as a collection of nodes (starting at a root node), where each node is a data structure consisting of a value, together with a list of references to nodes (the "children"), with the constraints that no reference is duplicated, and none points to the root.
    
\end{enumerate}

\subsection{Binary Tree}
    \begin{enumerate}
    \item A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.
    \item A binary tree is a data structure for storing data such as numbers in an organized way.
    \item Binary trees can be used to implement several types of abstract data types, such as sets, multisets, and associative arrays.
    \item Binary trees are a useful data structure for implementing many common abstract data types, such as priority queues, binary search trees, and heaps.
    \item Binary trees can be used to represent expressions involving binary operations.
\end{enumerate}

\subsubsection{Binary Tree Properties}
\begin{enumerate}
    \item The maximum number of nodes at level 'l' of a binary tree is 2l.
    \item Maximum number of nodes in a binary tree of height 'h' is 2h - 1.
    \item In a Binary Tree with N nodes, minimum possible height or minimum number of levels is \[log_2(N+1)\]
    \item A Binary Tree with L leaves has at least \[\lceil log_2(L+1)\rceil\] levels
\end{enumerate}

\subsubsection{Binary Tree Representation}
\begin{enumerate}
    \item A Binary Tree node contains following parts.
    \begin{enumerate}
        \item Data
        \item Pointer to left child
        \item Pointer to right child
    \end{enumerate}
\end{enumerate}

\subsubsection{Types of Binary Tree}
\begin{enumerate}
    \item Full Binary Tree
    \begin{enumerate}
        \item A Binary Tree is full if every node has 0 or 2 children.
        \item Number of leaf nodes is always one more than nodes with two children.
    \end{enumerate}
    \item Complete Binary Tree
    \begin{enumerate}
        \item A Binary Tree is complete Binary Tree if all levels are completely filled except possibly the last level and the last level has all keys as left as possible.
        \item This property of Binary Tree makes them suitable to be stored in an array.
    \end{enumerate}
    \item Perfect Binary Tree
    \begin{enumerate}
        \item A Binary tree is Perfect Binary Tree in which all internal nodes have two children and all leaves are at same level.
    \end{enumerate}
\end{enumerate}


\subsubsection{Different definitions related to binary tree.}

\begin{enumerate}
    \item \textit{Height} of a node is the number of edges on the longest path from the node to a leaf.
    \item \textit{Height} of a tree is the height of its root node.
    \item \textit{Depth} of a node is the number of edges from the node to the tree's root node.
    \item \textit{Level} of a node is defined as 1 + (the number of connections between the node and the root).
    \item \textit{Degree} of a node is the number of sub trees of a node.
    \item \textit{Degree} of a tree is the maximum degree of the nodes in the tree.
    \item \textit{Leaf} is a node with no children.
    \item \textit{Internal} node is a node with at least one child.
    \item \textit{Sibling} is a group of nodes with the same parent.
    \item \textit{Ancestor} is a node reachable by repeated proceeding from parent to parent.
    \item \textit{Descendant} is a node reachable by repeated proceeding to a child.
    \item \textit{Subtree} is a set of nodes and edges comprised of a parent and all the descendants of that parent.
    \item \textit{Forest} is a set of n Greater than or Equal to 0 disjoint trees.
\end{enumerate}

\subsection{Different Traversals (Inorder, Preorder and Postorder)}

\subsubsection{Inorder Traversal}
Inorder Traversal is a recursive algorithm for traversing or searching tree data structures. It starts at the tree's root node (or another designated node of a sub-tree), and explores the sub-tree's left branch until it reaches the left-most node (i.e., a node without a left child), which it then visits. It then explores the right branch in the same manner, i.e., it recursively visits the left-most node in that sub-tree, and so on, backtracking to the root node once all nodes have been visited.

\subsubsection{Algorithm for Inorder Recursive Travesal}
\begin{enumerate}
    \item Traverse the left subtree, i.e., call Inorder(left-subtree)
    \item Visit the root.
    \item Traverse the right subtree, i.e., call Inorder(right-subtree)

\end{enumerate}
\subsubsection{Algorithm for Inorder Iterative Travesal}

\begin{enumerate}
    \item Create an empty stack S.
    \item Initialize current node as root
    \item Push the current node to S and set current = current->left until current is NULL
    \item If current is NULL and stack is not empty then
    \begin{enumerate}
        \item Pop the top item from stack.
        \item Print the popped item, set current = poppedItem->right
        \item Go to step 3.
    \end{enumerate}
    \item If current is NULL and stack is empty then we are done.
\end{enumerate}

In the case of binary search trees (BST), Inorder traversal gives nodes in non-decreasing order. To get nodes of BST in non-increasing order, a variation of Inorder traversal where Inorder traversal is reversed can be used. 


\subsubsection{Preorder Traversal}
Preorder traversal is a recursive algorithm for traversing or searching tree data structures. It starts at the tree's root node (or another designated node of a sub-tree), visits the left subtree, then the right subtree. Printing the value of the root node after visiting the left and right subtrees. Preorder traversal is a depth-first traversal.

Preorder traversal is used to create a copy of the tree. Preorder traversal is also used to get prefix expressions on an expression tree.

\subsubsection{Algorithm for PreOrder Recursive Travesal}

\begin{enumerate}
    \item Visit the root.
    \item Traverse the left subtree, i.e., call Preorder(left-subtree)
    \item Traverse the right subtree, i.e., call Preorder(right-subtree)
\end{enumerate}

\subsubsection{Algorithm for PreOrder Iterative Travesal}

\begin{enumerate}
    \item Create an empty stack S.
    \item Initialize current node as root
    \item Push the root node to the stack. 
    \item Pop the top item from stack and set current node = poppedItem.
    \item Print the value of the node. 
    \item Push the right node if its not null, and then push the left node if its not null. 
    \item If stack isnt empty, go to step 4. 
    \item Exit algorithm when stack is empty.
\end{enumerate}


\subsubsection{Postorder Traversal}

\subsubsection{Algorithm for PostOrder Recursive Travesal}

\begin{enumerate}
    \item Traverse the left subtree, i.e., call Postorder(left-subtree)
    \item Traverse the right subtree, i.e., call Postorder(right-subtree)
    \item Visit the root.
\end{enumerate}

\subsubsection{Algorithm for PostOrder Iterative Travesal}
\begin{enumerate}
    \item Create empty stacks S1 and S2.
    \item Add the root node to S1. 
    \item Pop S1, and push the popped node to S2.
    \item Push the left and right node of the popped node to S1. 
    \item Repeat Step 3 and 4 until S1 is empty.
    \item Iterate through S2 and print the value of the node as it is popped.
\end{enumerate}



\section{Platform}
\textbf{Operating System}: Arch Linux x86-64 \\
\textbf{IDEs or Text Editors Used}: Visual Studio Code\\
\textbf{Compilers} : g++ and gcc on linux for C++\\

\section{Input}
\begin{enumerate}
	\item The Nodes of the Binary Tree
\end{enumerate}
\section{Output}
\begin{enumerate}
	\item The traversal of the binary tree in different ways.
\end{enumerate}

\section{Test Conditions}
\begin{enumerate}
	\item Input at least 10 nodes.
    \item Display all traversals of binary tree with 10 nodes.(recursive and nonrecursive)
\end{enumerate}

\section{Pseudo Code}

\subsection{Inorder Traversal - Iterative Approach}
\begin{lstlisting}[language=C++]
    void inorder_iterative(Node){
        if(Node == NULL){
            return;
        }
        stack<Node> s;
        Node current = Node;
        while(current != NULL || s.empty() == false){
            while(current != NULL){
                s.push(current);
                current = current->left;
            }
            current = s.top();
            s.pop();
            cout << current->data << " ";
            current = current->right;
        }
    }
\end{lstlisting}

\subsection{Preorder Traversal - Iterative Approach}

\begin{lstlisting}[language=C++]
    void preorder_iterative(Node){
        if(Node == NULL){
            return;
        }
        stack<Node> s;
        s.push(Node);
        while(s.empty() == false){
            Node current = s.top();
            cout << current->data << " ";
            s.pop();
            if(current->right){
                s.push(current->right);
            }
            if(current->left){
                s.push(current->left);
            }
        }
    }
\end{lstlisting}


\subsection{Postorder Traversal - Iterative Approach}

\begin{lstlisting}[language=C++]
    void postorder_iterative(Node){
        if(Node == NULL){
            return;
        }
        stack<Node> s1, s2;
        s1.push(Node);
        while(s1.empty() == false){
            Node current = s1.top();
            s1.pop();
            s2.push(current);
            if(current->left){
                s1.push(current->left);
            }
            if(current->right){
                s1.push(current->right);
            }
        }
        while(s2.empty() == false){
            Node current = s2.top();
            cout << current->data << " ";
            s2.pop();
        }
    }
\end{lstlisting}


\section{Time Complexity}
Time Complexities of different Traversals in their Iterative Approaches are as follows:
\begin{itemize}
    \item Inorder Traversal: O(n)
    \item Preorder Traversal: O(n)
    \item Postorder Traversal: O(n)
\end{itemize}

There is only a single loop involved in all of these traversals, so the time complexity is linear.

\section{Code}

\subsection{Program}
\lstinputlisting[language=C]{../Programs/Assignment_2.cpp}

\subsection{Input and Output}
\lstinputlisting[]{../Programs/Assignment_2_output.txt}

\section{Conclusion}
Thus, learnt about the different kinds of traversals in binary tree and also learnt about the recursive and non-recursive approach of programming.

\clearpage

\section{FAQ}
\begin{enumerate}
    \item Explain any one application of binary tree with suitable example.
    \item Explain sequential representation of binary tree with example.
    \item Write inorder, preorder and postorder for following tree.
    \begin{verbatim}
            18
         /     \
       15       30
      / \      /  \
     40   50  100  40
    / \  /  
   8  7 9              
    \end{verbatim}
    \textbf{Answer:}
    \begin{enumerate}
        \item Inorder: 8, 40, 7, 15, 9, 50, 18, 100, 30, 100, 40
        \item Preorder:  15, 40, 8, 7, 50, 9, 18, 30, 100, 40, 100
        \item Postorder: 8, 7, 40, 9, 50, 15, 100, 40, 100, 30, 18
    \end{enumerate}

\end{enumerate}

\end{document}