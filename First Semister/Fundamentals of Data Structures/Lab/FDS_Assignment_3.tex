\documentclass[11pt]{article}

% Preamble

\usepackage[margin=1in]{geometry}
\usepackage[table,xcdraw]{xcolor}

\usepackage{amsfonts, amsmath, amssymb}
\usepackage{fancyhdr, float, graphicx}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage{fouriernc} % Use the New Century Schoolbook font
\usepackage[nottoc, notlot, notlof]{tocbibind}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Header and Footer
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\textit{\Large{FDS Assignment 3 -Searching and Sorting}}}
%\fancyhead[R]{\textit{something}}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}



% Other Doc Editing
% \parindent 0ex
%\renewcommand{\baselinestretch}{1.5}

\begin{document}

\begin{titlepage}
	\centering

	%---------------------------NAMES-------------------------------

	\huge\textsc{
		MIT World Peace University
	}\\

	\vspace{0.75\baselineskip} % space after Uni Name

	\LARGE{
		Fundamental Data Structures\\
		Second Year B. Tech, Semester 1
	}

	\vfill % space after Sub Name

	%--------------------------TITLE-------------------------------

	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
	\rule{\textwidth}{0.6pt}
	\vspace{0.75\baselineskip} % Whitespace above the title



	\huge{\textsc{
			Searching and Sorting Algorithms
		}} \\



	\vspace{0.5\baselineskip} % Whitespace below the title
	\rule{\textwidth}{0.6pt}\vspace*{-\baselineskip}\vspace*{2.8pt}
	\rule{\textwidth}{1.6pt}

	\vspace{1\baselineskip} % Whitespace after the title block

	%--------------------------SUBTITLE --------------------------	

	\LARGE\textsc{
		Practical Report
	} % Subtitle or further description
	\vfill

	%--------------------------AUTHOR-------------------------------

	Prepared By
	\vspace{0.5\baselineskip} % Whitespace before the editors

	\Large{
		Krishnaraj Thadesar \\
		Cyber Security and Forensics\\
		Batch A2, PA 20
	}


	\vspace{0.5\baselineskip} % Whitespace below the editor list
	\today

\end{titlepage}


\tableofcontents
\thispagestyle{empty}
\clearpage


\setcounter{page}{1}

\section{Objectives}
\begin{enumerate}
	\item To understand use of an array of structures for maintaining records
	\item To implement, analyze and compare linear and binary search.
	\item To implement, analyze and compare selection, insertion sort and shell sort.
\end{enumerate}

\section{Problem Statements}
Write a C program to create a student database using an array of structures. Apply searching (Linear and Binary Search) and sorting techniques(Insertion Sort, Selection Sort, Shell sort).

\section{Theory}

\subsection{Searching}
\subsubsection{Linear Search}
Linear Search is defined as a sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found, otherwise the search continues till the end of the data set. It is the easiest searching algorithm
\subsubsection{Binary Search}
Binary search can be implemented only on a sorted list of items. If the elements are not sorted already, we need to sort them first.
Binary Search is a searching algorithm for finding an element's position in a sorted array. In this approach, the element is always searched in the middle of a portion of an array.

It can be implemented in 2 ways:
\begin{itemize}
	\item Iterative method
	\item Recursive Method
\end{itemize}
\subsection{Sorting}
\subsubsection{Selection Sort}
The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from the unsorted part and putting it at the beginning.

The algorithm maintains two subarrays in a given array.
\begin{itemize}
	\item The subarray which already sorted.
	\item The remaining subarray was unsorted.
\end{itemize}
In every iteration of the selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray.
\subsubsection{Insertion  Sort}
Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.

\begin{itemize}
	\item This algorithm is one of the simplest algorithm with simple implementation
	\item Basically, Insertion sort is efficient for small data values
	\item Insertion sort is adaptive in nature, i.e. it is appropriate for data sets which are already partially sorted.

\end{itemize}

\subsubsection{Shell sort}
Shell sort is a generalized version of the insertion sort algorithm. It first sorts elements that are far apart from each other and successively reduces the interval between the elements to be sorted.

The interval between the elements is reduced based on the sequence used. Some of the optimal sequences that can be used in the shell sort algorithm are:
\begin{itemize}
	\item Shell's original sequence: N/2 , N/4 , ..., 1
	\item Hibbard's increments: 1, 3, 7, 15, 31, 63, 127, 255, 511
	\item Pratt: 1, 2, 3, 4, 6, 9, 8, 12, 18, 27, etc
\end{itemize}
\section{Platform}
\textbf{Operating System}: Arch Linux x86-64 \\
\textbf{IDEs or Text Editors Used}: Visual Studio Code\\
\textbf{Compilers} : gcc on linux for C\\

\section{Input}

\begin{itemize}
	\item Array of Structures, so data of students
	\item Roll number, Marks and Name
	\item Which element to Search
	\item Which Sort to use.
\end{itemize}

\section{Output}
\begin{itemize}
	\item Menu to choose what to do
	\item Index of the Searched element, and its respective data
	\item Table of the entire Data sorted by chosen Algorithm.
\end{itemize}

\section{Test Conditions}
\begin{enumerate}
	\item Input at least five records.
	\item Search roll no which is not present using linear search and binary search
	\item Search roll no which is present at different locations using linear search and binary search.
	\item Test three sorting methods for at least five records.
\end{enumerate}

\section{Code}
\subsection{Pseudo Code}

\subsubsection{Pseudo Code for Implementation of Linear Search}
\begin{lstlisting}[language=C]
void linear_search(int a[], int n)
{
	//a is the array
	//n is the number to find
	int l, flag = 0;
	for(int i = 0;i < n;i++)
	{
		if(a[i] == n)
		{
			flag = 1;
			break;
		}
	}
	if(flag == 0)
	{
		return -1;
	}
}
\end{lstlisting}
\subsubsection{Pseudo Code for Implementation of Binary Search}
\begin{lstlisting}[language=C]
int binary_search_recursive(a[], int size, int low, int high, int key)
{
	int mid;
	if (low <= high)
	{
		mid = (low + high) / 2;
		if (a[mid] == key)
		{
			return mid;
		}
		else if (a[mid] > key)
		{
			return binary_search_recursive(a, size, low, mid - 1, key);
		}
		else if (a[mid] < key)
		{
			return binary_search_recursive(a, size, mid + 1, high, key);
		}
	}
	return -1;
}
\end{lstlisting}
\subsubsection{Pseudo Code for Implementation of Bubble Sort}
\begin{lstlisting}[language=C]
void Bubble_sort(int a[], int size, int key)
{
	for(int i = 0; i < size - 1; i++)
	{
		for(int j = 0; j < size - 2; j++)
		{
			if(a[j] > a[j + 1])
			{
				swap(a[j], a[j + 1])
			}
		}
	}
}
\end{lstlisting}
\subsubsection{Pseudo Code for Implementation of Insertion Sort}
\begin{lstlisting}[language=C]
void insertion_sort(int a[], int size, int key)
{
	for(i to size)
	{
		key = a[i]
		j = i - 1
		while(j >= 0 and a[j] > key)
		{
			a[j + 1] = a[j];
			j = j - 1;
		}
		a[j + 1] = key;
	}
}
\end{lstlisting}
\subsubsection{Pseudo Code for Implementation of Selection Sort}
\begin{lstlisting}[language=C]
void selection_sort(int arr[], int size, int key)
{
	for i to size
	{
		min_pos = i;
		for j = i + 1 to size - 1
		{
			if a[j] < a[min_pos]
			{
				min_pos = j;
			}
		}
	}
	if(min_pos != i)
	{
		swap(a[i], a[min_pos])
	}
}
\end{lstlisting}

\subsection{C Implementation of Problem Statement}

\lstinputlisting[language=c++, caption=Main.Cpp]{../Programs/[Krishnaraj]_[FDS]_Assignment_3.c}

\subsection{C Output}
\lstinputlisting[caption=Outpute]{../Programs/[Krishnaraj]_[FDS]_Assignment_3_output.txt}

\section{Time Complexity}
\begin{itemize}
	\item Time Complexity of Linear Search is: $\Omega(1)$, O(n)
	\item Time Complexity of Binary Search is: $\Omega(1)$, $O(\log(n))$
	\item Time Complexity of Bubble Sort is: $\Omega(n)$, $O(n^2)$
	\item Time Complexity of Insertion Sort is: $\Omega(n)$, $O(n^2)$
	\item Time Complexity of Selection Sort is: $\Omega(n^2)$, $O(n^2)$
	\item Time Complexity of Shell Sort is: $\Omega(n \log(n))$, $O(n^2)$
\end{itemize}

\section{Conclusion}
Thus, implemented different searching and sorting methods on the student database. This System is able to perform searching and sorting under different cases.

\section{FAQs}
\begin{enumerate}
	\item \textbf{What is the meaning of database? How to maintain in C ?}\\
	      A Database is simple a collection of data kept securely and readily accessible by the CPU, program or the user, to read or write to as many times as needed.
	      It can be maintained in C is a few ways:
	      \begin{itemize}
		      \item Using a Simple Structure, and then creating an array of structure objects.
		      \item Using File IO operations in C, to read to and write from files.
		      \item Arrays, linked lists, and other data structures, which could be created at runtime or compile time for ready processing or be transferred to files to act as long term databases.
	      \end{itemize}
	\item \textbf{What are the applications of searching and sorting?}\\
	      Here are some Applications of Searching Algorithms:
	      \begin{enumerate}
		      \item Find an element in a sorted array
		      \item To find if n is a square of an integer
		      \item Find the first value greater than or equal to x in a given array of sorted integers
		      \item Find the frequency of a given target value in an array of integers
		      \item Find the peak of an array which increases and then decreases
		      \item A sorted array is rotated n times. Search for a target value in the array.
		      \item Dictionary
		      \item Debugging a linear piece of code
		      \item Figuring out resource requirements for a large system
		      \item Find values in sorted collection
		      \item Semiconductor test programs
		      \item Numerical solutions to an equation
	      \end{enumerate}

	      \textbf{Here are some Applications of Sorting Algorithms}:
	      \begin{enumerate}
		      \item Sort a list of names.
		      \item Organize an MP3 library.
		      \item Display Google PageRank results.
		      \item List RSS news items in reverse chronological order.
		      \item Find the median.
		      \item Find the closest pair.
		      \item Binary search in a database.
		      \item Identify statistical outliers.
		      \item Find duplicates in a mailing list.
		      \item Data compression.
		      \item Computer graphics.
		      \item Computational biology.
		      \item Supply chain management.
		      \item Load balancing on a parallel computer
	      \end{enumerate}

	      \textbf{Sorting Algorithms in Particular have some unique features that help them to be used in niche fields of science and Real life Application. Some are} :
	      \begin{enumerate}
		      \item Selection Sort - Selection sort does not require a lot of memory so it can be used where memory is a constraint. Since memory is not a big problem nowadays, selection sort is rarely used.

		      \item Insertion Sort - Insertion sort is used in sort() function in java along with quick sort. When the data to be sorted is reduced to a small size, insertion sort works great.

		      \item Shell Sort - Shell sort is used when calling a stack is overhead. It is used in C standard libraries. Also shell sort is used in linux kernels.

		      \item Merge Sort - Variant of merge sort i.e. tim sort, is used in standard sorting algorithm of python. It can be used for sorting linked lists.

		      \item Heap Sort - Heap sort is used in the implementation of priority queues. It is also used in embedded systems and systems concerned with security.

		      \item Quick Sort - It is used in traditional java sorting. It is also used in event driven simulation.

		      \item Radix Sort - Radix sort can be used where data is to be sorted in lexicographical order like strings or numbers. It can be used when numbers are in a large range and sorting them using counting sort will take more time.
	      \end{enumerate}
	\item \textbf{Compare and contrast linear search and binary search?}\\
	      \begin{table}[H]
		      \begin{tabular}{ll}
			      \hline
			      \multicolumn{1}{|l|}{\textbf{Linear Search}}                                                                               & \multicolumn{1}{l|}{\textbf{Binary Search}}                                                                                 \\ \hline
			      \rowcolor[HTML]{FFFFFF}
			      \multicolumn{1}{|l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} In linear search input data need not to be in sorted.}} & \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} In binary search input data need to be in sorted order.}} \\ \hline
			      \rowcolor[HTML]{FFFFFF}
			      \multicolumn{1}{|l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} It is also called sequential search.}}                  & \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} It is also called half-interval search.}}                 \\ \hline
			      \rowcolor[HTML]{FFFFFF}
			      \multicolumn{1}{|l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} The time complexity of linear search O(n).}}            & \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} The time complexity of binary search O(log n).}}          \\ \hline
			      \rowcolor[HTML]{FFFFFF}
			      \multicolumn{1}{|l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} Multidimensional array can be used.}}                   & \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} Only single dimensional array is used.}}                  \\ \hline
			      \rowcolor[HTML]{FFFFFF}
			      \multicolumn{1}{|l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} Linear search performs equality comparisons}}           & \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} Binary search performs ordering comparisons}}             \\ \hline
			      \rowcolor[HTML]{FFFFFF}
			      \multicolumn{1}{|l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} It is less complex.}}                                   & \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} It is more complex.}}                                     \\ \hline
			      \rowcolor[HTML]{FFFFFF}
			      \multicolumn{1}{|l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} It is very slow process.}}                              & \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFFF}{\color[HTML]{131417} It is very fast process.}}                                \\ \hline
		      \end{tabular}
	      \end{table}
	\item \textbf{Compare and contrast bubble, selection, insertion sort and shell sort.}\\
	      \begin{enumerate}
		      \item \textit{Bubble Sort}: \\
		            \textbf{Time Complexity: }\\
		            Best Case Sorted array as input. Or almost all elements are in proper place. [ O(N) ]. O(1) swaps.\\
		            Worst Case: Reversely sorted / Very few elements are in proper place. [ O(N2) ] . O(N2) swaps.\\
		            Average Case: [ O(N2) ] . O(N2) swaps.\\\\
		            \textbf{Space Complexity}: A temporary variable is used in swapping [ auxiliary, O(1) ]. Hence it is In-Place sort. \\
		            \textbf{Advantage: }\\
					\begin{itemize}
						\item It is the simplest sorting approach.
						\item Best case complexity is of O(N) [for optimized approach] while the array is sorted.
						\item Using optimized approach, it can detect already sorted array in first pass with time complexity of O(N).
						\item Stable sort: does not change the relative order of elements with equal keys.
						\item In-Place sort.\\
					\end{itemize}
		            \textbf{Disadvantage: }\\
		            Bubble sort is comparatively slower algorithm.
		      \item \textit{Selection Sort}:\\
		            \textbf{Time Complexity: }\\
		            Best Case [ O(N2) ]. And O(1) swaps.\\
		            Worst Case: Reversely sorted, and when the inner loop makes a maximum comparison. [ O(N2) ] . Also, O(N) swaps.\\
		            Average Case: [ O(N2) ] . Also O(N) swaps.\\\\
		            \textbf{Space Complexity}: [ auxiliary, O(1) ]. \\In-Place sort.(When elements are shifted instead of being swapped (i.e. temp=a[min], then shifting elements from ar[i] to ar[min-1] one place up and then putting a[i]=temp).  If swapping is opted for, the algorithm is not In-place.)\\\\
		            \textbf{Advantage: }\\
		            \begin{itemize}
						\item It can also be used on list structures that make add and remove efficient, such as a linked list. Just remove the smallest element of unsorted part and end at the end of sorted part.
						\item The number of swaps reduced. O(N) swaps in all cases.
						\item In-Place sort.
					\end{itemize}
		            \textbf{Disadvantage: }\\
		            Time complexity in all cases is O(N2), no best case scenario.
		      \item \textit{Insertion Sort}: \\
		            \textbf{Time Complexity: }\\
		            Best Case Sorted array as input, [ O(N) ]. And O(1) swaps.\\
		            Worst Case: Reversely sorted, and when inner loop makes maximum comparison, [ O(N2) ] . And O(N2) swaps.\\
		            Average Case: [ O(N2) ] . And O(N2) swaps.\\\\
		            \textbf{Space Complexity}: [ auxiliary, O(1) ]. In-Place sort.\\\\
		            \textbf{Advantage: }
					\begin{itemize}
						\item It can be easily computed.
						\item Best case complexity is of O(N) while the array is already sorted.
						Number of swaps reduced than bubble sort.
						\item For smaller values of N, insertion sort performs efficiently like other quadratic sorting algorithms.
						Stable sort.
						\item Adaptive: total number of steps is reduced for partially sorted array.
						In-Place sort.
					\end{itemize}
		            \textbf{Disadvantage: }\\
		            It is generally used when the value of N is small. For larger values of N, it is inefficient.
		      \item Shell Sort: \\
		            \textbf{Time Complexity: }\\
		            Best Case : When the given array list is already sorted the total count of comparisons of each interval is equal to the size of the given array. So best case complexity is O(n log(n))\\
		            Worst Case: The worst-case complexity for shell sort is  O(n2)\\
		            Average Case: The shell sort Average Case Complexity depends on the interval selected by the programmer.
		            O(n log(n)2).\\\\
		            \textbf{Space Complexity}: The space complexity of the shell sort is O(1).\\
		            \textbf{Advantage: }
					\begin{itemize}						
						\item Replacement for insertion sort, where it takes long time to complete given task.
						\item To call stack overhead we use shell sort.
						\item when recursion exceeds a particular limit we use shell sort.
						\item For medium to large-sized datasets.
						\item In insertion sort to reduce the  number of operations .
					\end{itemize}
	      \end{enumerate}
\end{enumerate}
\end{document}