\documentclass[11pt]{article}

% Preamble

\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb}
\usepackage{fancyhdr, float, graphicx}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage{fouriernc} % Use the New Century Schoolbook font
\usepackage[nottoc, notlot, notlof]{tocbibind}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Header and Footer
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\textit{\Large{FDS Assignment 9}}}
%\fancyhead[R]{\textit{something}}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}

\begin{document}

\begin{titlepage}
	\centering

	%---------------------------NAMES-------------------------------

	\huge\textsc{
		MIT World Peace University
	}\\

	\vspace{0.75\baselineskip} % space after Uni Name

	\LARGE{
		Fundamental Data Structures\\
		Second Year B. Tech, Semester 1
	}

	\vfill % space after Sub Name

	%--------------------------TITLE-------------------------------

	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
	\rule{\textwidth}{0.6pt}
	\vspace{0.75\baselineskip} % Whitespace above the title

	\huge{\textsc{
			Job Scheduling using Circular Queue
		}} \\



	\vspace{0.5\baselineskip} % Whitespace below the title
	\rule{\textwidth}{0.6pt}\vspace*{-\baselineskip}\vspace*{2.8pt}
	\rule{\textwidth}{1.6pt}

	\vspace{1\baselineskip} % Whitespace after the title block

	%--------------------------SUBTITLE --------------------------	

	\LARGE\textsc{
		Practical Report\\
		Assignment 9
	} % Subtitle or further description
	\vfill

	%--------------------------AUTHOR-------------------------------

	Prepared By
	\vspace{0.5\baselineskip} % Whitespace before the editors

	\Large{
		Krishnaraj Thadesar \\
		Cyber Security and Forensics\\
		Batch A1, PA 20
	}


	\vspace{0.5\baselineskip} % Whitespace below the editor list
	\today

\end{titlepage}


\tableofcontents
\thispagestyle{empty}
\clearpage
\setcounter{page}{1}

\section{Aim}
Writing a C Program to simualate job scheduling using a linear queue.
\section{Objectives}
\begin{enumerate}
	\item To study Queue and its operations
	\item To study the importance of queue as a data structure in computer science
\end{enumerate}

\section{Problem Statements}
\textit{Queues are frequently used in computer programming, and a typical example is the creation of a
	job queue by an operating system. If the operating system does not use priorities, then the jobs
	are processed in the order they enter the system. Write a program for simulating job queue. Write
	functions to add job and delete job from queue.}

\section{Theory}
\subsection{Queue}
A queue is a linear data structure that follows the FIFO (First In First Out) principle. It is a
simple data structure that allows adding and removing elements in a particular order. A real-life
example of a queue is a line of people at a ticket counter. The first person in the line is the
first one to get the ticket and the last person in the line is the last one to get the ticket. The
elements are added at the end of the queue and are removed from the front of the queue. The
operations that can be performed on a queue are:
\begin{enumerate}
	\item Enqueue: Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition.
	\item Dequeue: Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition.
	\item Front: Get the front item from queue.
	\item Rear: Get the last item from queue.
\end{enumerate}


\subsection{Types of Queues}
\begin{enumerate}
	\item \textbf{Linear Queue}: The elements are stored in a linear fashion. The elements are added from one end and removed from the other end. The insertion and deletion operations are performed at the two ends of the queue. The insertion operation is called enqueue and the deletion operation is called dequeue.
	\item \textbf{Circular Queue}: The elements are stored in a circular fashion. The elements are added from one end and removed from the other end. The insertion and deletion operations are performed at the two ends of the queue. The insertion operation is called enqueue and the deletion operation is called dequeue.
	\item \textbf{Priority Queue}: This queue is a special type of queue. Its specialty is that it arranges the elements in a queue based on some priority. The priority can be something where the element with the highest value has the priority so it creates a queue with decreasing order of values. The priority can also be such that the element with the lowest value gets the highest priority so in turn it creates a queue with increasing order of values.
	\item \textbf{Dequeue:} Dequeue is also known as Double Ended Queue. As the name suggests double ended, it means that an element can be inserted or removed from both the ends of the queue unlike the other queues in which it can be done only from one end. Because of this property it may not obey the First In First Out property. 
\end{enumerate}

\subsection{Applications of Queue}
\begin{enumerate}
	\item \textbf{CPU Scheduling}: The operating system uses a queue to keep track of the processes that are in the ready state. The process that is at the front of the queue is the one that is currently being executed by the CPU. The process that is at the rear of the queue is the one that is waiting to be executed.
	\item \textbf{Disk Scheduling}: The operating system uses a queue to keep track of the disk requests that are waiting to be serviced. The request that is at the front of the queue is the one that is currently being serviced by the disk. The request that is at the rear of the queue is the one that is waiting to be serviced.
	\item \textbf{Call Center Phone Systems}: The phone system uses a queue to keep track of the incoming phone calls. The call that is at the front of the queue is the one that is currently being serviced by the phone system. The call that is at the rear of the queue is the one that is waiting to be serviced.
\end{enumerate}


\section{Platform}
\textbf{Operating System}: Arch Linux x86-64 \\
\textbf{IDEs or Text Editors Used}: Visual Studio Code\\
\textbf{Compilers} : gcc on linux for C\\

\section{Input}
The element or Job number to pass to the queue
\section{Output}
The Queue
\section{Test Conditions}
DeleteQ(), AddQ(), AddQ(),delete(),delete(),delete()
\section{Code}
\subsection{Pseudo Code for Add to linear Queue}
\begin{lstlisting}[language=C]
AddQ()
{
	if (rear == MAX-1)
	{
		printf("Queue Overflow");
	}
	else
	{
		if (front == -1)
		{
			front = 0;
		}
		printf("Enter the value to be added in the queue : ");
		scanf("%d", &add_item);
		rear = rear + 1;
		queue_array[rear] = add_item;
	}
}

\end{lstlisting}


\subsection{Pseudo Code for Delete to linear Queue}

\begin{lstlisting}[language=C]

DeleteQ()
{
	if (front == - 1 || front > rear)
	{
		printf("Queue Underflow \n");
		return ;
	}
	else
	{
		printf("Element deleted from queue is : %d\n", queue_array[front]);
		front = front + 1;
	}
}


\end{lstlisting}


\subsection{Pseudo Code to check isEmpty for linear Queue}

\begin{lstlisting}[language=C]

isEmpty()
{
	if (front == -1)
	{
		printf("Queue is empty");
	}
	else
	{
		printf("Queue is not empty");
	}
}

\end{lstlisting}

\subsection{Pseudo Code for check isFull for linear Queue}

\begin{lstlisting}[language=C]

isFull()
{
	if (rear == MAX-1)
	{
		printf("Queue is full");
	}
	else
	{
		printf("Queue is not full");
	}
}

\end{lstlisting}


\subsection{Pseudo Code for Add to Circular Queue}

\begin{lstlisting}[language=C]

AddQ()
{
	if ((rear + 1) % MAX == front)
	{
		printf("Queue Overflow \n");
	}
	else
	{
		if (front == -1)
		{
			front = 0;
		}
		printf("Inset the element in queue : ");
		scanf("%d", &add_item);
		rear = (rear + 1) % MAX;
		queue_array[rear] = add_item;
	}
}

\end{lstlisting}


\subsection{Pseudo Code for Delete to Circular Queue}

\begin{lstlisting}[language=C]

DeleteQ()
{
	if (front == -1)
	{
		printf("Queue Underflow \n");
	}
	else
	{
		printf("Element deleted from queue is : %d\n", queue_array[front]);
		if (front == rear)
		{
			front = -1;
			rear=-1;
		}
		else
		{
			front = (front + 1) % MAX;
		}
	}
}

\end{lstlisting}


\subsection{Pseudo Code to check isEmpty for Circular Queue}

\begin{lstlisting}[language=C]

isEmpty()
{
	if (front == -1)
	{
		printf("Queue is empty");
	}
	else
	{
		printf("Queue is not empty");
	}
}

\end{lstlisting}

\subsection{Pseudo Code for check isFull for Circular Queue}

\begin{lstlisting}[language=C]

isFull()
{
	if ((rear + 1) % MAX == front)
	{
		printf("Queue is full");
	}
	else
	{
		printf("Queue is not full");
	}
}

\end{lstlisting}


\subsection{C Implementation of Problem Statement}

\lstinputlisting[language=C, caption=Main.Cpp]{../Programs/[Krishnaraj]_[FDS]_Assignment_9.c}

\subsection{Input and Output}
\lstinputlisting[caption=Output]{../Programs/[Krishnaraj]_[FDS]_Assignment_9_output.txt}

\section{Time Complexity}
\begin{itemize}
	\item AddQ() : O(1)
	\item DeleteQ() : O(1)
	\item isEmpty() : O(1)
	\item isFull() : O(1)
\end{itemize}

\section{Conclusion}
Thus, implemented Job Scheduling using Linear Queue in C.


\section{FAQs}
\begin{enumerate}
	\item \textbf{What are the advantages and disadvantages of a linear queue ?}\\
	      \textbf{Advantages}
	      \begin{enumerate}
		      \item A large amount of data can be managed efficiently with ease.
		      \item Operations such as insertion and deletion can be performed with ease as it follows the first in first out rule.
		      \item Queues are useful when a particular service is used by multiple consumers.
		      \item Queues are fast in speed for data inter-process communication.
		      \item Queues can be used in the implementation of other data structures.
	      \end{enumerate}
	      \textbf{Disadvantages}
	      \begin{enumerate}
		      \item As the insertion in the queue is from the rear end and in the case of Linear Queue of fixed size insertion is not possible when rear reaches the end of the queue.
		      \item But in the case of Circular Queue, the rear end moves from the last position to the front position circularly.
	      \end{enumerate}
	\item \textbf{What are the advantages and disadvantages of a circular queue ?}\\
	      \textbf{Advantages}
	      \begin{enumerate}
		      \item Easier for insertion-deletion: In the circular queue, elements can be inserted easily if there are vacant locations until it is not fully occupied, whereas in the case of a linear queue insertion is not possible once the rear reaches the last index even if there are empty locations present in the queue.
		      \item Efficient utilization of memory: In the circular queue, there is no wastage of memory as it uses the unoccupied space, and memory is used properly in a valuable and effective manner as compared to a linear queue.
		      \item Ease of performing operations: In the linear queue, FIFO is followed, so the element inserted first is the element to be deleted first. This is not the scenario in the case of the circular queue as the rear and front are not fixed so the order of insertion-deletion can be changed, which is very useful.
	      \end{enumerate}

	      \textbf{Disadvantages}

	      \begin{enumerate}
		      \item Circular queue is not suitable for implementing the BFS algorithm as it is not FIFO.
		      \item Circular queue is not suitable for implementing the DFS algorithm as it is not LIFO.
		      \item Searching an element takes O(N) time.
		      \item Maximum size of a queue must be defined prior.
	      \end{enumerate}

	\item \textbf{Give various applications to the queue .}\\
	      \begin{enumerate}
		      \item Queue used to model real-world situations such as people waiting in line at a bank, airplanes
		            waiting to take off, or data packets waiting to be transmitted over the Internet.
		      \item There are various queues quietly doing their job in your computer's (or the network's) operating
		            system.
		      \item There's a printer queue where print jobs wait for the printer to be available.
		      \item Stores, reservation centers, and other similar services typically process customer requests
		            according to the FIFO principle. A queue would therefore be a logical choice for a data structure to
		            handle transaction processing for such applications. For example, it would be a natural choice for
		            handling calls to the reservation center of an airline.
		      \item CPU Scheduling
		      \item Disk Scheduling
		      \item Handling of interrupts in real-time systems
		      \item ATM Booth Line
		      \item icket Counter Line
		      \item Key press sequence on the keyboard
		      \item CPU task scheduling
		      \item Waiting time of each customer at call centers.
	      \end{enumerate}


\end{enumerate}
\end{document}

