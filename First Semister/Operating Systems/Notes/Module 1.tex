% This is a basic Math Paper

\documentclass[11pt]{article}

% Preamble

\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb}
\usepackage{fancyhdr, float, graphicx}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage{fouriernc} % Use the New Century Schoolbook font
\usepackage[nottoc, notlot, notlof]{tocbibind}
\usepackage{url}

% Header and Footer
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\textit{\Large{Operating Systems}}}
%\fancyhead[R]{\textit{something}}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}



% Other Doc Editing
% \parindent 0ex
%\renewcommand{\baselinestretch}{1.5}

\begin{document}

\begin{titlepage}
	\centering

	%---------------------------NAMES-------------------------------

	\huge\textsc{
		MIT World Peace University
	}\\

	\vspace{0.75\baselineskip} % space after Uni Name

	\LARGE{
		Computer Networks\\
		Second Year B.Tech Semister 3\\
		Academic Year 2022-23
	}

	\vfill % space after Sub Name

	%--------------------------TITLE-------------------------------

	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
	\rule{\textwidth}{0.6pt}
	\vspace{0.75\baselineskip} % Whitespace above the title



	\huge{\textsc{
			Operating Systems
		}} \\



	\vspace{0.5\baselineskip} % Whitespace below the title
	\rule{\textwidth}{0.6pt}\vspace*{-\baselineskip}\vspace*{2.8pt}
	\rule{\textwidth}{1.6pt}

	\vspace{1\baselineskip} % Whitespace after the title block

	%--------------------------SUBTITLE --------------------------	

	\LARGE\textsc{
		Notes from Tananbaum and Classes
	} % Subtitle or further description
	\vfill

	%--------------------------AUTHOR-------------------------------

	Prepared By
	\vspace{0.5\baselineskip} % Whitespace before the editors

	\Large{
		P34. Krishnaraj Thadesar\\
		\vspace{1cm}
		Batch A2
	}


	\vspace{0.5\baselineskip} % Whitespace below the editor list
	\today

\end{titlepage}

\clearpage
\tableofcontents
\clearpage


\section{Introduction}

A modern computer system consists of one of more processors, RAM, ROM, IO devices, and a lot of stuff, this is like common knowledge, and known to everyone. Which means we know that a computer is alot of things happening at the same time, and if the programmer was to know all the things that were happening in the computer, and he or she had to deal with whether or not the frequency of pulse sent to the motor of the hard disk is greater than the required amount every time they needed to create a variable or something, then it simply would not be possible to write any code.



\section{Operating System}
What is an operating system?

\begin{enumerate}
	\item It is a program that acts as an intermediary between a user and the hardware.
	\item It is also the program taht controls the execution of application programs.
	\item It allocates resources effectively.
\end{enumerate}

The main Objective is convenience, efficiency and providing an environment. It has a kernel, and is always running all the time.

\paragraph{Modes of Operation}

The Operating system is the most important piece of software and runs in the kernal mode. The rest of the softwares run in the user modes.
\subparagraph{Kernal Mode}
This is where You get complete access to all the hardware and software components of the system. It is also called the supervisor mode. You can do anything here and that is why it needs to be kept secure, and is often restricted to the users.

\subparagraph{User Mode}
This is where all the interaction takes place from the user. Most of the software that we see is written to work only in this space.


\subparagraph{The User Interface Program}

This is the shell or the GUI. As the name suggests, it is the way to interact with the user and the system.

It is not important that every kind of operating system has these modes. Embedded systems for examples may have only 1 mode, coz they are often simple in design.

\begin{itemize}
	\item Operating systems are much bigger than normal software, something like 5 million lines.
	\item They are mostly in the kernel mode, but the boundary often blurs.
	\item Coz they are so long to write, companies would often not mess with what they already have, and just build on that than starting from scratch.
\end{itemize}

\paragraph{It is an extended machine}
The hardware is difficult to program, and OSs use abstraction very nicely to make us programmers feel that it is easy. Abstraction is therefore a key to managing any kind of complexity. A good abstraction can turn a nearly impossible task into 2 manageable ones. To define and implement them, and to use them to solve the problme. \\
It is the job of the OS to turn some ugly interface into a beautiful one. 
\paragraph{It is A Resource Manager}
This is again self explanatory, but more importantly, it includes multiplexing resources in time as well as in space. The usual example is the one where 3 programs might want to print something on the screen, and save some data on the disk, if the OS doesnt bring order to chaos, its just gonna be all together and messed up. 

\section{History of the OS}
Im pretty sure this isnt needed for the exam, but id rahter write it coz its interesting.\\ OS types have been closely related to the type of CPU architecture. 

\subsection{Babbage - 1850s}
The father of the computer. This guy was a mathematician. He wanted to make an analygical engine, and obviously that means everything was all mechanical, which meant there wasnt much software. But as he realized he couldnt coordinate everything without a software, he hired a young woman named Ada Lovelace, who was the daughter of Lord Byron, that poet dude. The programming language Ada is therefore named after her. 

\subsection{First Generation (1945-1955) Vacuum Tubes}
That date should ring some bells, no wonder, the advancements came at this time. The first functioning digital computer was built at IOwa state uni with 300 vacuum Tubes. All these took seconds to perform even simple calculations. All programming at this time was done by pure machine language, or by literally connecting thousands of cables. \\
By the 50s, the job of the operating system had to be done by programmers. You had to manually write your program in a punch card, and write your name and purpose on the signup sheet, and once you did that you would wait for your turn and insert your program and wait for the results. 

\subsection{The Second Generation (1955-65) - Transistors}
With transistors, we could get rid of vacuum tubes, and therefore increase reliabilty, while reducing size. Now these machines are called mainframes. You still have to do essentially the same thing, excpet now you write the program in Assembly or FORTRAN, and punch it to cards and wait for output. 

To make this better, people started using blocks, and a different computer for loading programs into tapes, so things were faster. The output was printed by a computer that wasnt connected to the main line, and was therefore \textit{Off Line}

The page that the programmer had to submit however had much the same structure as we see now. They first had to write the JOB card, specify run time, then a FORTRAN card, telling the OS (usually IBM SYS OS) to load the FORTRAN compiler from the system tape, then the program to be compiled, then a LOAD Card and finally the RUN and END card. In this way an entire program was submitted to the system. 

\subsection{The Third Generation - ICs and Multiprogramming}

The development of ICs meant that you could now fit larger computers in a smaller size. IBM Tried to integrate different types of computers, into a series of computers that would all be compatible with each other, the IBM 360 Series. It could handle commercial as well as scientific computing. There was a family of such computers meant for different tasks, but all were meant to be compatible with each other. Now we know what that means. The Operating system was Huge. It had to manage running efficiently on a potato computer and a solid scientific computer. This meant thousands of computers were needed, and every release of this OS was riddled with bugs. And yet it was still a success. 

\begin{itemize}
	\item It introduced multiprogramming. This meant you could hae serveral jobs run at the same time. Explained more later. So now a lot of the IO time was reduced, and CPU was suddenly very efficient. 
	\item It could read jobs from cards onto the disks as soon as they were brought into the computer room. This was called SPOOLing
	\item It introduced timesharing, as programmers didnt wanna wait for so long to debug their programs. 
\end{itemize}

\subsubsection{MULTICS}
General Electric, MIT and Bell Labs envisioned that like the electricity grid, you could have something like a computer grid, where you could have a bunch of computing power for everyone in Boston. You should just be able to connect and use it. It was kinda popular and saw mixed success. It was later bought by Honeywell. As you might notice this is kinda like the server design. \\
Another major development during the third gen was the growth of minicomputers. Ken Thompson, found a small minicomputer that was a stripped down one user version of MULTICs. This was later developed into the UNIX Operating System that we all know and love. 

UNIX then branched out into System V and BSD. To make it possible to write programs on any of these distributions, IEEE Developed POSIX. POSIX is a minimal standard system call interface for UNIX systems. And the BASH shell is based on it. \\
This then led to the development of MINIX for educational purposes, and later, the desire for a free production as opposed to just educational version of MINIX is what led a Finnish Student, Linux Torvalds to develop Linux.

\subsection{Fourth Gen of Computers. (1980- Present)}




\section{Shells and Scripts}

\paragraph{System Calls}

System calls are what are called by the operating system to the kernel. When you say things like printf and all they then invoke system calls
Examples are read(), write() etc

\subsection{Shell}
The shell is simply another program on top of the kernel which provides a basic human os interface.

There are different types of shells

\begin{enumerate}
	\item /bin/csh - It is the C Shell
	\item /bin/tcsh - Enhanced C Shell
	\item /bin/sh - The Bourne Shell / POSIX shell
	\item /bin/ksh - Korn Shell
	\item /bin/bash - Korn Shell Clone from GNU
\end{enumerate}

All linux systems use the bash shell as the default.

\subsection{Scripts}
A script is a bunch of lines of the script written in a plain text file.

\subparagraph{Why should we write shell script?}
\begin{enumerate}
	\item Shell script can take input from the user or file and then output them on the screen.
	\item Useful to create our own commands. Save lots of time
	\item To automate some tast of daily life.
	\item System administration part can be automated.
\end{enumerate}

\subparagraph{Practical Examples where you can use scripts}
\begin{enumerate}
	\item Monitor your systemdata backupFind out what process are taking up resources
	\item Find out which memory is free
	\item Find which users are logged in
	\item Find out if all necdessary network services are running etc.
\end{enumerate}


\section{OS Components and Functions}

\subsection{Process Management and CPU scheduling}
\textit{A Process is when a part of your program is in its execution state.}\\
A program is on a higher level than the process. One Program can have a lot of processes. On an even higher level is the job or the task. The tast is the highest level. Whenever you say something exclusively in your program, then doing that is caleld a process.\\
A process needs certain resources, including CPU time, memory, files, and IO devices. \\

The Operating system is responsible for the following activities
\begin{enumerate}
	\item Process creation and deletion
	\item Process suspension and resumption
	\item Provision of mechanisms for process synchronization  and Process communication
\end{enumerate}

\subsection{Memory Management}
\begin{enumerate}
	\item Memory is a large array of words or bytes. Each with its own address
	\item It is a repository of quickly accessible data shared by the CPU and IO devices
	\item Main memory is a volatile storage device. It loses its contents in case of a system failure.
	\item The Operating system is responsible for the following activities in connections with memory management
	      \begin{enumerate}
		      \item Keeping track of which parts of the memory are currently being used and by whom.
		      \item Deciding which process to load when memory space becomes available
		      \item Allocating and deallocating memory space as needed.
	      \end{enumerate}


\end{enumerate}
\subsection{File Management}

There are 2 types of Files. Sequential and Direct Access Files.

\begin{enumerate}
	\item A File is a collection of related information defined by its created. Commonly files represent programs and data
	\item The operating system is responsible for the following activities in connections with file mangement.
	      \begin{enumerate}
		      \item File creating and deletion
		      \item Directory creation and deletion
		      \item Support of primitives for manipulating files and directories.
		      \item Mapping files onto secondary storage. File backup on stable or non volatile storage media.
	      \end{enumerate}

\end{enumerate}

\subsection{IO System management}

\begin{enumerate}
	\item Control of devices connected to computer
	\item IO Devices vary widely in their function and speed, so different methods are needed to control them.
	\item Device drivers are required to provide an interface to IO devices
	\item Also the IO system consists uses buffering to take care of speed difference between IO devices and processor.
\end{enumerate}

\section{Types of Programming}

\begin{enumerate}
	\item Uni Programming
	      \begin{enumerate}
		      \item Process must wait for IO instruction to complete before proceeding
		      \item The processor spends a certain amount of time executing, until it reaches an IO instruction. It must wait until that IO instruction concludes before proceeding.
		      \item 2 Programs cannot be run at the same time. The OS takes care of this, and makes sure that that doesnt happen.
		      \item This is usually run in Single core CPUs.
	      \end{enumerate}

	\item Multi Programming
	      \begin{enumerate}
		      \item Several jobs are kept in the main memory at the same time and the cpu is multiplexed among them.
		      \item There must be enough memory hold hte OS and one user program.
		      \item When one job needs to wait for IO, the processor can switch to the other job, which is likey not waiting for IO.
		      \item So you might confuse this with multithreading, its not that, we are still running stuff serially on a single cored CPU, but it feels like a lot of things are happening at the same time.
		      \item So you can actaully simulate doing many tasks at the same time, while still performing them serially. The CPU does not need to wait, if the processes arent output dependent on each other.
		      \item The CPU is \textit{multiplexed} here
	      \end{enumerate}

\end{enumerate}
\section{Types of Operating Systems}
\subsection{Time Sharing Systems}
\begin{enumerate}
	\item Can be used to handle multiple interactive jobs.
	\item Processor time is shared among multiple users.
	\item  Multiple users simultaneously access the system through terminals, with theos interleaving the execution of each use program in short burst or quentum of computation.
	\item An operating system that uses multi tasking like seen above, then that would also be a time sharing system.
\end{enumerate}

\subsection{Distributed OS}
\begin{enumerate}
	\item Distributed system is a collection of loosely coupled (less dependent) processors interconnected by a communications network.
	\item Processors variously called nodes, computers, machines, hosts.
	\item gves the impression thatthere is a sigle operating system controlling the network.
	\item Users not aware of multiplicity of machines Access to remote resources similar to access to local ones.
	\item Advantages are Resource sharing, Reliability, Communication, Computational Speed up.
	\item An Example is banking and stuff.
\end{enumerate}

\subsection{Real Time and Embedded OS}

\begin{enumerate}
	\item Rigid time requirements are placed on operation of a processor or flow of data
	\item Often used as a control device in a dedicatd application such as controlling scientific experiments, medical imaging systems, industrial control systems, and some display systems.
	\item Well defined fixed time constraints and rocessing must be done within define constraints.
	\item Real Time Systems may be either hard or soft real time.
	\item Example is a Washing Machine for Embedded OS, the OS in Heart Monitor Systems would be a Real Time system.
	\item Real time and Embedded OS go hand in hand.

\end{enumerate}

\section{Operating System Structure}

\subsection{Types}
\subsubsection{Monolithic}
The Main point here is that everything is in the kernel. This makes it rather efficient, but also a little insecure.
\begin{enumerate}
	\item Every component contained in kernal.
	\item Direct communication among all elements.
	\item Highly Efficient
	\item Problems are complexity, new devices, emerging tech enabling, protection etc.
\end{enumerate}

In the kernal Space, we have several things in the kernal that can be called by the system call interface.
Those things are:
\begin{enumerate}
	\item Memory Manager
	\item Processor Scheduler
	\item Interprocess Communication
	\item file system
	\item Input/Output
	\item Network Manager etc.
\end{enumerate}


\subsubsection{Layered}
\begin{enumerate}
	\item The Problem with monolithic is that it was kinda less secure.
	\item Flow of communication is different.
	\item Its like a hierarchical thing, where you need permissions and stuff, so this makes it more secure.
	\item The different layers would be the computer hardware -> operating systems -> utilities -> Application Programs.

\end{enumerate}

\subsubsection{MicroKernel Approach}
\begin{itemize}
	\item Kernel is modularized using micro kernel approach. 
	\item It removes all non essential components from kernel and implements them as system and user level programs. 
	\item It provides minimal process and memory menagement, in addition to communication facility. 
	\item Other OS servies are provided by processes, called as servers that run in user mode and are treated like any other application by microkernel. (eg. diff file organizations can be implemented as one service), Device drivers, file systems, security services. 
	\item It provides communication between client program and various services that are running in user space. 
	\item communication is provided by message passing. called MPI. 
	\item Clients and services communicate by exchanging messages with microkernel and not directly. 
	\item Things like application programs, file systems device drivers etc all come in the user mode here. In the kernel mode, you have interprocess comm, memory management, and CPU Scheduling. 
	\item Notice the differences here, user can access a lot of things here as opposed to monolithic kernels. 
\end{itemize}

Benefits of Microkernel Design: 
\begin{enumerate}
	\item Uniform Interface: Uniform interface on requests made by process. Processes are not distinguished as user or kernel level, since services are provided by means of messages passing between them. 
	\item Extendibility: Easy of extending OS
	\item Flexibility: New services are added to the user space and no modification required at kernel level. Existing features can be subtracted to produce smaller and efficient implementation. 
	\item Kernel level modifications are very few. 
	\item Portability OS is easier to port from one Hardware design to another. 
	\item Provides more security and reliability., since most services are running at user level. 
	\item If service fails, rest of OS remains unchanged. This is so that no one can interfere with Kernel architecture and stuff. 
	\item Examples would  be Tru64Unix, or Apple MacOS
\end{enumerate}



\end{document}