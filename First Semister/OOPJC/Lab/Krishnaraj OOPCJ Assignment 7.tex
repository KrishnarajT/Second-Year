% This is a Basic Assignment Paper but with like Code and stuff allowed in it. 

\documentclass[11pt]{article}

% Preamble

\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb}
\usepackage{fancyhdr, float, graphicx}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage{fouriernc} % Use the New Century Schoolbook font
\usepackage[nottoc, notlot, notlof]{tocbibind}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Header and Footer
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\textit{\Large{OOPJC Assignment 7}}}
%\fancyhead[R]{\textit{something}}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}



% Other Doc Editing
% \parindent 0ex
%\renewcommand{\baselinestretch}{1.5}

\begin{document}

\begin{titlepage}
	\centering

	%---------------------------NAMES-------------------------------

	\huge\textsc{
		MIT World Peace University
	}\\

	\vspace{0.75\baselineskip} % space after Uni Name

	\LARGE{
		Object Oriented Programming with Java and C++\\
		Second Year B. Tech, Semester 1
	}

	\vfill % space after Sub Name

	%--------------------------TITLE-------------------------------

	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
	\rule{\textwidth}{0.6pt}
	\vspace{0.75\baselineskip} % Whitespace above the title



	\huge{\textsc{
			Multithreading using Thread Class and Runnable Interface in Java
		}} \\



	\vspace{0.5\baselineskip} % Whitespace below the title
	\rule{\textwidth}{0.6pt}\vspace*{-\baselineskip}\vspace*{2.8pt}
	\rule{\textwidth}{1.6pt}

	\vspace{1\baselineskip} % Whitespace after the title block

	%--------------------------SUBTITLE --------------------------	

	\LARGE\textsc{
		Practical Report\\
		Assignment 7
	} % Subtitle or further description
	\vfill

	%--------------------------AUTHOR-------------------------------

	Prepared By
	\vspace{0.5\baselineskip} % Whitespace before the editors

	\Large{
		Krishnaraj Thadesar \\
		Cyber Security and Forensics\\
		Batch A1, PA 20
	}


	\vspace{0.5\baselineskip} % Whitespace below the editor list
	\today

\end{titlepage}


\tableofcontents
\thispagestyle{empty}
\clearpage


\setcounter{page}{1}

\section{Aim and Objectives}
\subsection*{Aim}
Implementing Solutions on Multithreading using Thread Class and Runnable Interface
\subsection*{Objectives}
\begin{enumerate}
	\item To understand Multithreading in Java
	\item To learn two different ways to create threads in Java
\end{enumerate}
\section{Problem Statements}

\subsection{Problem 1 in Java}
Write a program to create a multithreaded calculator that does addition, subtraction,
multiplication, and division using separate threads.
Additionally also handle '/ by zero' exception by the division method.

\subsection{Problem 2 in Java}
Print even and odd numbers in increasing order using two threads in Java

\section{Theory}
\subsection{Multithreading in Java}
\textit{
	In Java, Multithreading refers to a process of executing two or more threads simultaneously for maximum utilization of the CPU. A thread in Java is a lightweight process requiring fewer resources to create and share the process resources.Multithreading and Multiprocessing are used for multitasking in Java, but we prefer multithreading over multiprocessing.
}

\subsection{Life Cycle of a Thread in Java}
There are five states a thread has to go through in its life cycle. This life cycle is controlled by JVM (Java Virtual Machine). These states are:
\begin{enumerate}
	\item New : In this state, a new thread begins its life cycle. This is also called a born thread. The thread is in the new state if you create an instance of Thread class but before the invocation of the start() method.
	\item Runnable : A thread becomes runnable after a newly born thread is started. In this state, a thread would be executing its task.
	\item Running : When the thread scheduler selects the thread then, that thread would be in a running state.
	\item Non-Runnable (Blocked) : The thread is still alive in this state, but currently, it is not eligible to run.
	\item Terminated : A thread that is in a terminated state does not consume ant cycle of the CPU.
\end{enumerate}

\subsection{Ways of Creating a Thread}
There are multiple ways of creating Threads in Java
\begin{enumerate}
	\item By Extending the Thread Class
	      \begin{lstlisting}[language=Java]
class Multi extends Thread{  
	public void run(){  
		System.out.println("thread is running...");  
	}  
	public static void main(String args[]){  
		Multi t1=new Multi();  
		t1.start();  
	}  
}  		
	\end{lstlisting}
	\item By Implementing the Runnable Interface
	      \begin{lstlisting}[language=Java]
class Multi3 implements Runnable{  
	public void run(){  
		System.out.println("thread is running...");  
	}  

	public static void main(String args[]){  
		Multi3 m1=new Multi3();  
		Thread t1 =new Thread(m1);   // Using the constructor Thread(Runnable r)  
		t1.start();  
	}   
}
	\end{lstlisting}
	\item Using the Thread Class
	      \begin{lstlisting}[language=Java]
public class MyThread1  
{
	// Main method  
	public static void main(String argvs[])  
	{  
		// creating an object of the Thread class using the constructor Thread(String name)   
		Thread t= new Thread("My first thread");  

		// the start() method moves the thread to the active state  
		t.start();  
		// getting the thread name by invoking the getName() method  
		String str = t.getName();  
		System.out.println(str);  
	}  
}  
\end{lstlisting}
\end{enumerate}
\subsection{Performing Multiple tasks by multiple threads}
You could just create multiple classes that perform their own tasks, each a child of the Thread class. So you could then invoke instances of those classes, and run them as multiple threads.

\begin{lstlisting}[language=Java]
class MultithreadEx3 extends Thread  
{  
    public void run()  
    {  
        System.out.println("Start task one");  
    }  
}  
class MultithreadEx4 extends Thread  
{  
    public void run()  
    {  
        System.out.println("Start task two");  
    }  
}  
class Run  
{  
    public static void main(String args[])  
    {  
        MultithreadEx3 th1 = new MultithreadEx3();  
        MultithreadEx4 th2 = new MultithreadEx4();  
        th1.start();  
        th2.start();  
    }  
} 
\end{lstlisting}
\subsection{Thread Scheduler}
A component of Java that decides which thread to run or execute and which thread to wait is called a thread scheduler in Java. In Java, a thread is only chosen by a thread scheduler if it is in the runnable state.\\

However, if there is more than one thread in the runnable state, it is up to the thread scheduler to pick one of the threads and ignore the other ones. There are some criteria that decide which thread will execute first. There are two factors for scheduling a thread i.e. Priority and Time of arrival.

\begin{itemize}
	\item \textit{Priority}: Priority of each thread lies between 1 to 10. If a thread has a higher priority, it means that thread has got a better chance of getting picked up by the thread scheduler.

	\item \textit{Time of Arrival}: Suppose two threads of the same priority enter the runnable state, then priority cannot be the factor to pick a thread from these two threads. In such a case, arrival time of thread is considered by the thread scheduler. A thread that arrived first gets the preference over the other threads.
\end{itemize}


\subsection{Joining a Thread in Java}
java.lang.Thread class provides the join() method which allows one thread to wait until another thread completes its execution.\\

If t is a Thread object whose thread is currently executing, then t.join() will make sure that t is terminated before the next instruction is executed by the program.
If there are multiple threads calling the join() methods that means overloading on join allows the programmer to specify a waiting period.\\

However, as with sleep, join is dependent on the OS for timing, so you should not assume that join will wait exactly as long as you specify.
There are three overloaded join functions.
\begin{lstlisting}[language=Java]
public class JoinExample1 extends Thread  
{    
    public void run()  
    {    
        for(int i=1; i<=4; i++)  
        {    
            try 
            {    
                Thread.sleep(500);    
            }catch(Exception e){System.out.println(e);}    
            System.out.println(i);    
        }    
    }    
    public static void main(String args[])  
    {   
        JoinExample1 thread1 = new JoinExample1();    
        JoinExample1 thread2 = new JoinExample1();    
        JoinExample1 thread3 = new JoinExample1();    
        thread1.start();   
       try 
        {    
        thread1.join();    
        }catch(Exception e){System.out.println(e);}    
        thread2.start();   
        thread3.start();    
    }    
}
\end{lstlisting}
\section{Platform}
\textbf{Operating System}: Arch Linux x86-64 \\
\textbf{IDEs or Text Editors Used}: Visual Studio Code\\
\textbf{Compilers} : g++ and gcc on linux for C++, and javac, with JDK 18.0.2 for Java\\

\section{Input}
\subsection*{For Problem 1}
\begin{enumerate}
	\item 2 numbers
	\item Choice about what to do with those numbers
\end{enumerate}
\subsection*{For Problem 2}
\begin{enumerate}
	\item The Maximum limit up to which the user wants to see the odd and even numbers printed
\end{enumerate}

\section{Output}
\subsection*{For Problem 1}
\begin{enumerate}
	\item Menu about what to do with numbers
	\item Output of the calculation done with those numbers
\end{enumerate}
\subsection*{For Problem 2}
\begin{enumerate}
	\item Even numebers and Odd numbers in Ascending order upto the specified limit.
\end{enumerate}


\section{Code}

\subsection{Java Implementation of Problem 1}

\lstinputlisting[language=java, caption=Probelm 1.java]{../Programs/java_implementations/assignment_7/assignment_7_problem_1.java}

\subsubsection{Java Output}
\lstinputlisting[caption=Output for Problem 1 - calculations]{../Programs/java_implementations/assignment_7/problem_1_output.txt}

\subsection{Java Implementation of Problem 2}

\lstinputlisting[language=java, caption=Multithreading Even Odd]{../Programs/java_implementations/assignment_7/assignment_7_problem_2.java}

\subsubsection{Java Output}
\lstinputlisting[caption=Output for ProblemHillStation 2]{../Programs/java_implementations/assignment_7/problem_2_output.txt}


\section{Conclusion}
Thus, learnt the use of thread class in java and performed multithreading operations.

\pagebreak

\section{FAQs}

\begin{enumerate}
	\item \textit{What are the challenges for multithreading implementation using Java Programming?}\\
	      \begin{enumerate}
		      \item \textbf{Difficulty of writing code}: Multithreaded and multicontexted applications are not easy to write. Only experienced programmers should undertake coding for these types of applications.

		      \item \textbf{Difficulty of debugging}: It is much harder to replicate an error in a multithreaded or multicontexted application than it is to do so in a single-threaded, single-contexted application. As a result, it is more difficult, in the former case, to identify and verify root causes when errors occur.


		      \item \textbf{Difficulty of managing concurrency}: The task of managing concurrency among threads is difficult and has the potential to introduce new problems into an application.


		      \item \textbf{Difficulty of testing}: Testing a multithreaded application is more difficult than testing a single-threaded application because defects are often timing-related and more difficult to reproduce.


		      \item \textbf{Difficulty of porting existing code}: Existing code often requires significant re-architecting to take advantage of multithreading and multicontexting. Programmers need to:
		            \begin{itemize}
			            \item Remove static variables
			            \item Replace any function calls that are not thread-safe
			            \item Replace any other code that is not thread-safe
		            \end{itemize}
	      \end{enumerate}
	\item \textit{What is the difference between the start and run method in Java Thread? }\\
	      \textbf{start()}
	      \begin{itemize}
		      \item Creates a new thread and the run() method is executed on the newly created thread.
		      \item Can't be invoked more than one time otherwise throws java.lang.IllegalStateException
		      \item Defined in java.lang.Thread class.
	      \end{itemize}
	      \textbf{run()}
	      \begin{itemize}
		      \item No new thread is created and the run() method is executed on the calling thread itself.
		      \item Multiple invocation is possible.
		      \item It is just a normal function in Runnable Interface.
		      \item Defined in java.lang.Runnable interface and must be overriden in the implementing class.
	      \end{itemize}
	\item \textit{Which one is better to implement thread in Java? extending Thread class or implementing Runnable?}\\
	      \begin{enumerate}
		      \item The significant differences between extending Thread class and implementing Runnable interface
		      \item When we extend Thread class, we cant extend any other class even we require and When we implement Runnable, we can save a space for our class to extend any other class in future or now.
		      \item When we extend Thread class, each of our thread creates unique object and associate with it. When we implements Runnable, it shares the same object to multiple threads.
	      \end{enumerate}
	\item \textit{What is the difference between wait and sleep in Java? Explain with example.}\\
	      \textbf{wait()}:
	      \begin{itemize}
		      \item Wait() method belongs to Object class.
		      \item Wait() method releases lock during Synchronization.
		      \item Wait() should be called only from Synchronized context.
		      \item Wait() is not a static method.
		      \item Wait() Has Three Overloaded Methods:
		            \begin{enumerate}
			            \item wait()
			            \item wait(long timeout)
			            \item wait(long timeout, int nanos)
		            \end{enumerate}
	      \end{itemize}
	      \textbf{sleep()}
	      \begin{itemize}
		      \item Sleep() method belongs to Thread class.
		      \item Sleep() method does not release the lock on object during Synchronization.
		      \item There is no need to call sleep() from Synchronized context.
		      \item Sleep() is a static method.
		      \item Sleep() Has Two Overloaded Methods:
		            \begin{enumerate}
			            \item sleep(long millis)millis: milliseconds
			            \item sleep(long millis,int nanos) nanos: Nanoseconds
		            \end{enumerate}
	      \end{itemize}
	\item \textit{What is the difference between the submit() and execute() method of Executor and ExecutorService in Java? Explain with example.}\\
	      \textbf{submit()}:
	      \begin{enumerate}
		      \item This function executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.
		      \item Unlike the execute method, this method returns a future. The future object is used to handle the task after the execution has started.
		      \item Therefore, when we need the result of the execution, then we can use the submit() method of the future object. In order to get the result, we can use the get() methods on the Future. The get() method returns an object.
		            \begin{lstlisting}[language=Java]
				import java.util.concurrent.*;
public class Test {
    public static void main(String[] args) throws Exception
    {
        ExecutorService executorService = Executors.newFixedThreadPool(1);
        Future obj = executorService.submit(new Callable() {
                  // Overriding the call method
                  public Object call()
                  {
                      System.out.println(
                          "This is submit() "
                          + "method example");
 
                      return "Returning Callable "
                          + "Task Result"; 
                  }
              });
        System.out.println(obj.get());
        executorService.shutdown();
    }
}
			  \end{lstlisting}
	      \end{enumerate}
	      \textbf{execute()}:
	      \begin{enumerate}
		      \item This function executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.
		      \item This method is a void method meaning it doesn't return any function. Once the task is assigned in the execute() method, we won't get any response and we can forget about the task.-
		            \begin{lstlisting}[language=Java]				
import java.util.concurrent.*;
public class Test {

	public static void main(String[] args) throws Exception
	{

		ExecutorService executorService = Executors.newSingleThreadExecutor();
		executorService.execute(new Runnable() {
			// Override the run method
			public void run()
			{
				System.out.println(
					"This is execute() "
					+ "method example");
			}
		});				
		executorService.shutdown();
	}
}

			  \end{lstlisting}
	      \end{enumerate}

\end{enumerate}

\end{document}