% This is a Basic Assignment Paper but with like Code and stuff allowed in it. 

\documentclass[11pt]{article}

% Preamble

\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb}
\usepackage{fancyhdr, float, graphicx}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage{fouriernc} % Use the New Century Schoolbook font
\usepackage[nottoc, notlot, notlof]{tocbibind}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Header and Footer
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\textit{\Large{OOPJC Assignment 5}}}
%\fancyhead[R]{\textit{something}}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}



% Other Doc Editing
% \parindent 0ex
%\renewcommand{\baselinestretch}{1.5}

\begin{document}

\begin{titlepage}
	\centering

	%---------------------------NAMES-------------------------------

	\huge\textsc{
		MIT World Peace University
	}\\

	\vspace{0.75\baselineskip} % space after Uni Name

	\LARGE{
		Object Oriented Programming with Java and C++\\
		Second Year B. Tech, Semester 1
	}

	\vfill % space after Sub Name

	%--------------------------TITLE-------------------------------

	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
	\rule{\textwidth}{0.6pt}
	\vspace{0.75\baselineskip} % Whitespace above the title



	\huge{\textsc{
			Implementation of STL in C++
		}} \\



	\vspace{0.5\baselineskip} % Whitespace below the title
	\rule{\textwidth}{0.6pt}\vspace*{-\baselineskip}\vspace*{2.8pt}
	\rule{\textwidth}{1.6pt}

	\vspace{1\baselineskip} % Whitespace after the title block

	%--------------------------SUBTITLE --------------------------	

	\LARGE\textsc{
		Practical Report
	} % Subtitle or further description
	\vfill

	%--------------------------AUTHOR-------------------------------

	Prepared By
	\vspace{0.5\baselineskip} % Whitespace before the editors

	\Large{
		Krishnaraj Thadesar \\
		Cyber Security and Forensics\\
		Batch A1, PA 20
	}


	\vspace{0.5\baselineskip} % Whitespace below the editor list
	\today

\end{titlepage}


\tableofcontents
\thispagestyle{empty}
\clearpage


\setcounter{page}{1}

\section{Aim and Objectives}
\begin{itemize}
	\item To understand the user of Standard Template Library in C++
	\item To get familiar with list containers and iterators.
\end{itemize}
\section{Problem Statement}
\textit{	A shop maintains the inventory of items. It stores information of items like ItemCode, ItemName, Quantity and Cost of it in a list of STL. Whenever Customer wants to buy an item, sales person inputs the ItemCode and or ItemName and the system searches in a
	file and displays whether it is available or not otherwise an appropriate message is displayed. If it is, then the system displays the item details and request for the quantity of items required. If the requested quantity of items are available, the total cost of items is
	displayed; otherwise the message is displayed as required items not in stock. After purchasing an item, system updates the list.
	Design a system using a class called Items with suitable data members and member functions. Implement a Menu Driven C++ program using STL concepts.}

\section{Theory}
\subsection{Concept of Standard Template Library}
The Standard Template Library (STL) is a set of C++ template classes to provide common programming data structures and functions such as lists, stacks, arrays, etc. It is a library of container classes, algorithms, and iterators. It is a generalized library and so, its components are parameterized. It has a lot of useful things that we can use in our own code, without worrying to write lengthy implementations of basic data structure concepts.

STL has 4 components:
\begin{enumerate}
	\item Algorithms : \textit{They act on containers and provide means for various operations for the contents of the containers.}
	\item Containers : \textit{Containers or container classes store objects and data. }
	\item Functions :\textit{The STL includes classes that overload the function call operator. Instances of such classes are called function objects or functors.}
	\item Iterators : \textit{As the name suggests, iterators are used for working upon a sequence of values. They are the major feature that allows generality in STL.}
\end{enumerate}

\subsection{How is STL different from the C++ Standard Library?}
The \textbf{STL} was written by Alexander Stepanov in the days long before C++ was standardised.
The STL was already widely used as a library for C++, giving programmers access to containers, iterators and algorithms. When the standardisation happened, the language committee designed parts of the C++ Standard Library (which is part of the language standard) to very closely match the STL.

Over the years, many people — including prominent book authors, and various websites — have continued to refer to the C++ Standard Library as \textbf{The STL} despite the fact that the two entities are separate and that there are some differences. These differences are even more pronounced in the upcoming new C++ standard, which includes various features and significantly alters some classes.

So A lot of the functions and containers were written before the formation of various important libraries that we now use in C++. It is those libraries that are called the "STL". C++ standard libaries are ones written after it using those libraries in part.

\subsection{Concept of Containers, Ierators and Algorithms}
\subsubsection{Containers}
In C++, there are generally 3 kinds of STL containers:

\begin{itemize}
	\item Sequential Containers : \textit{In C++, sequential containers allow us to store elements that can be accessed in sequential order.
		      Internally, sequential containers are implemented as arrays or linked lists data structures.}

	      Types of Sequential Containers
	      \begin{itemize}
		      \item Array
		      \item Vector
		      \item Deque
		      \item List
		      \item Forward List
	      \end{itemize}
	      \begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
using namespace std;

int main() {
	// initialize a vector of int type
	vector<int> numbers = {1, 100, 10, 70, 100};
	
	// print the vector
	cout << "Numbers are: ";
	for(auto &num: numbers) {
		cout << num << ", ";
	}
	
	return 0;
}

//Output
Numbers are: 1, 100, 10, 70, 100,
\end{lstlisting}

	\item Associative Containers: \textit{In C++, associative containers allow us to store elements in sorted order. The order doesn't
		      depend upon when the element is inserted. Internally, they are implemented as binary tree data structures.}
	      Types of associative Containers.
	      \begin{itemize}
		      \item Set
		      \item Map
		      \item Multiset
		      \item Multimap
	      \end{itemize}

	      \begin{lstlisting}[language= C++]
			#include <iostream>
			#include <set>
			using namespace std;
			
			int main() {
			
				// initialize a set of int type
				set<int> numbers = {1, 100, 10, 70, 100};
				
				// print the set
				cout << "Numbers are: ";
				for(auto &num: numbers) {
					cout << num << ", ";
				}
				
				return 0;
			}			
			// Output: 
			Numbers are: 1, 10, 70, 100,
		  \end{lstlisting}
	\item Unordered Associative Containers: \textit{In C++, STL Unordered Associative Containers provide the unsorted versions of the associative container. Internally, unordered associative containers are implemented as hash table data structures.}
	      Types of Unordered Associated Containers
	      \begin{itemize}
		      \item Unordered Set
		      \item Unordered Map
		      \item Unordered Multiset
		      \item Unordered Multimap
	      \end{itemize}

	      \begin{lstlisting}[language=C++]
#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
	
	// initialize an unordered_set of int type
	unordered_set<int> numbers = {1, 100, 10, 70, 100};
	
	// print the set
	cout << "Numbers are: ";
	for(auto &num: numbers) {
		cout << num << ", ";
	}
	
	return 0;
}
// Output
Numbers are: 70, 10, 100, 1,
	\end{lstlisting}
\end{itemize}


\subsubsection{Iterators}
\textit{Iterators are one of the four pillars of the Standard Template Library or STL in C++. An iterator is used to point to the memory address of the STL container classes. For better understanding, you can relate them with a pointer, to some extent.
	Iterators act as a bridge that connects algorithms to STL containers and allows the modifications of the data present inside the container. They allow you to iterate over the container, access and assign the values, and run different operators over them, to get the desired result.}\\

\noindent
Applications of Iterators:
\begin{enumerate}
	\item The primary objective of an iterator is to access the STL container elements and perform certain operations on them.
	\item The internal structure of a container does not matter, since the iterators provide common usage for all of them.
	\item Iterator algorithms are not dependent on the container type.
	\item An iterator can be used to iterate over the container elements. It can also provide access to those elements to modify their values.
	\item Iterators follow a generic approach for STL container classes. This way, the programmers dont need to learn about different iterators for different containers.
\end{enumerate}
\textbf{Example to Demonstrate use of Iterators}
\begin{lstlisting}[language=C++]
#include<iostream>
#include<iterator> // for iterators
#include<vector> // for vectors
using namespace std;
int main()
{
	vector<int> ar = { 1, 2, 3, 4, 5 };
		
	// Declaring iterator to a vector
	vector<int>::iterator ptr;
		
	// Displaying vector elements using begin() and end()
	cout << "The vector elements are : ";
	for (ptr = ar.begin(); ptr < ar.end(); ptr++)
		cout << *ptr << " ";
		
	return 0;    
}
//Output
The vector elements are : 1 2 3 4 5 
\end{lstlisting}
\subsubsection{Algorithms}
\textit{STL provide different types of algorithms that can be implemented upon any of the container with the help of iterators. Thus now we don't have to define complex algorithm instead we just use the built in functions provided by the algorithm library in STL.
}\\

Algorithm functions provided by algorithm library works on the iterators, not on the containers. Thus one algorithm function can be used on any type of container. Use of algorithms from STL saves time, effort, code and are very reliable.

There are many types of algorithms already implemented reliably in the STL. Here we will use a simple Non Modifying Algorithm as an example.

\begin{lstlisting}[language=C++]
#include <iostream>   
#include <algorithm>
using namespace std;
int main ()
{
	int values[] = {5,1,6,9,10,1,12,5,5,5,1,8,9,7,46};
	int count_5 = count(values, values+15, 5);
	cout<<"The number of times '5' appears in array= "<<count_5;
	return 0;
}
// Output
The number of times 5 appears in an array= 4	
\end{lstlisting}
\section{Platform}
\textbf{Operating System}: Arch Linux x86-64 \\
\textbf{IDEs or Text Editors Used}: Visual Studio Code\\
\textbf{Compilers} : g++ and gcc on linux for C++\\

\section{Input}

\subsection*{For C++}
\begin{enumerate}
	\item Basic menu to add new elements, or purchase an item.
	\item The Details of the item to add.
	\item The quantity and code of the product that you wanna purchase.
\end{enumerate}

\section{Output}
\subsection*{For C++}
\begin{enumerate}
	\item A list of all the elements in the Database.
	\item Their codes and Quantities
	\item Appropriate messages after each action is performed.
\end{enumerate}

\section{Code}
\subsection{C++ Implementation of Problem A}

\lstinputlisting[language=c++, caption=Main.Cpp]{../Programs/cpp_implementations/Krishnaraj_Assignment_5.cpp}

\subsubsection{C++ Input and Output}
\lstinputlisting[caption=Output for Problem 1]{../Programs/cpp_implementations/Krishnaraj_Assignment_5_output.txt}

\section{Conclusion}
Thus, the purpose of the STL libraries in C++ was understood, and implemented successfully. Containers like lists and iterators for them were also used and understood.

\pagebreak
\section{FAQs}
\begin{enumerate}
	\item \textbf{What are class templates? How are they created? What is the need for class templates?}\\
	      Templates are powerful features of C++ which allows us to write generic programs. There are two ways we can implement templates:
	      \begin{itemize}
		      \item Function Templates
		      \item Class Templates
	      \end{itemize}
	      Similar to function templates, we can use class templates to create a single class to work with different data types.
	      There are few, but important reasons to use class templates:
	      \begin{itemize}
		      \item Class templates come in handy as they can make our code shorter and more manageable.
		      \item If you have various functions that you wanna implement on a set of data, but you arent sure which data type will be given as input, then you can use class templates.
		      \item Example: If you creating a calculator, a class template to include basic functions like addition, subtraction etc would be perfect as you can get an integer or a floating point value as your input for your calculator.
	      \end{itemize}
	\item \textbf{Create a template for bubble sort functions.}\\
	      \begin{lstlisting}[language=C++]
template <class T>
T bubbleSort(T arr[], int n)
{
	int i, j;
	for (i = 0; i < n - 1; i++)
		for (j = 0; j < n - i - 1; j++)
			if (arr[j] > arr[j + 1])
				swap(arr[j], arr[j + 1]);
}
			
	\end{lstlisting}
	\item \textbf{Explain with example, how Function Templates are implemented?}\\
	      \begin{lstlisting}[language=C++]
#include <iostream>  
using namespace std;  
template<class T> T add(T &a,T &b)  
{  
	T result = a+b;  
	return result;  
}
int main()  
{  
	int i =2;  
	int j =3;  
	float m = 2.3;  
	float n = 1.2;  
	cout<<"Addition of i and j is :"<<add(i,j);  
	cout<<'\n';  
	cout<<"Addition of m and n is :"<<add(m,n);  
	return 0;  
}  
		\end{lstlisting}
	\item \textbf{Explain with example how can a class template be created.}\\
	      \begin{lstlisting}[language=C++]
// Class template
template <class T>
class Number {
	private:
	// Variable of type Tf
	T num;

	public:
	Number(T n) : num(n) {}   // constructor

	T getNum() {
		return num;
	}
};

int main() {

	// create object with int type
	Number<int> numberInt(7);

	// create object with double type
	Number<double> numberDouble(7.7);

	cout << "int Number = " << numberInt.getNum() << endl;
	cout << "double Number = " << numberDouble.getNum() << endl;

	return 0;
}
// Output
int Number = 7
double Number = 7.7	
	\end{lstlisting}
	\item \textbf{Explain Generic functions and Generic class.}\\
	      \begin{itemize}
		      \item Generic functions use the concept of a function template. Generic functions define a set of operations that can be applied to the various types of data.
		      \item The type of the data that the function will operate on depends on the type of the data passed as a parameter.
		      \item For example, Quick sorting algorithm is implemented using a generic function, it can be implemented to an array of integers or array of floats.
		      \item A Generic function is created by using the keyword template. The template defines what function will do.
		      \item Just like a class is a collection of a bunch of functions, that can be inherited and instantiated at once, generic functions are similar in that manner, except in a generic class, you could use a generic data type, and this would be applicable and useful for implementing each function in the Class. So each function in the class can be called and can manipulate variables of the genereic data type for which the class is defined.
	      \end{itemize}
\end{enumerate}

\end{document}