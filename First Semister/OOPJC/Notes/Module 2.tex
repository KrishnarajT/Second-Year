% This is a basic Math Paper

\documentclass[11pt]{article}

% Preamble

\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb}
\usepackage{fancyhdr, float, graphicx}
\usepackage[utf8]{inputenc} % Required for inputting international characters
\usepackage[T1]{fontenc} % Output font encoding for international characters
\usepackage{fouriernc} % Use the New Century Schoolbook font
\usepackage[nottoc, notlot, notlof]{tocbibind}
\usepackage{url}

% Header and Footer
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\textit{\Large{Object Oriented Programming}}}
%\fancyhead[R]{\textit{something}}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}



% Other Doc Editing
% \parindent 0ex
%\renewcommand{\baselinestretch}{1.5}

\begin{document}

\begin{titlepage}
	\centering

	%---------------------------NAMES-------------------------------

	\huge\textsc{
		MIT World Peace University
	}\\

	\vspace{0.75\baselineskip} % space after Uni Name

	\LARGE{
		Computer Networks\\
		Second Year B.Tech Semister 3\\
		Academic Year 2022-23
	}

	\vfill % space after Sub Name

	%--------------------------TITLE-------------------------------

	\rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
	\rule{\textwidth}{0.6pt}
	\vspace{0.75\baselineskip} % Whitespace above the title



	\huge{\textsc{
			Module 1 - Class Notes
		}} \\



	\vspace{0.5\baselineskip} % Whitespace below the title
	\rule{\textwidth}{0.6pt}\vspace*{-\baselineskip}\vspace*{2.8pt}
	\rule{\textwidth}{1.6pt}

	\vspace{1\baselineskip} % Whitespace after the title block

	%--------------------------SUBTITLE --------------------------	

	\LARGE\textsc{
		Notes
	} % Subtitle or further description
	\vfill

	%--------------------------AUTHOR-------------------------------

	Prepared By
	\vspace{0.5\baselineskip} % Whitespace before the editors

	\Large{
		P34. Krishnaraj Thadesar\\
		\vspace{1cm}
		Batch A2
	}


	\vspace{0.5\baselineskip} % Whitespace below the editor list
	\today

\end{titlepage}

\clearpage
\tableofcontents
\clearpage


\section{Things to do}
\begin{enumerate}
	\item Types of Inheritance
	\item Virtual base Classs
	\item Polymorphism
	\item Vitual functions
\end{enumerate}

\section{Inheritance}

\begin{itemize}
	\item It is the mechanism by which one class acquires the properties of another class
	\item Provides a way to create a new class from an existing class
	\item The new class is a specialized fersion of the existing class
	\item Inheritance establishes an "is a" relationship or a parent child relationship between classes. 
	\item Allows sharing off the behavior of the parent class into its child classes
	\item child class can add new behavior or override existing behaviour from parent
	\item It allows a hierarchy of classes to be built moving from the most general to the most specific class. 
\end{itemize}

\subsection{Differnece between overloading and overiding}
\begin{itemize}
	\item Overloading is when you write the same function many times within the same class
	\item Overriding is when you do that same thing, but in sub classes. 
\end{itemize}

\subsection{Benefits of using Inheritance}
\begin{itemize}
	\item Reusablity : Reuse the methods and data of the existing class
	\item Extendability: Extend the existing class by adding new data and new methods. 
	\item Modifyability: Modify the existang class by overloading its methods with newer implementations, saves memory space, increases reliability, saves the developing process. 
\end{itemize}

\section{Class Derivation in C++}
syntax: class DerivedClassName : specification BaseClassName\\
like class child : public parent() // private by default
{};

\section{Types of Inheritance}
{
	\begin{enumerate}
		\item Single level Inheritance : You have 1 base class --> 1 Child class.
		\item Multiple Inheritance : 2 or more Base Classes --> 1 Child Class
		\item Multi-Level inheritance : 1 Base Class --> 1 Child Class --> Another Child Class and so on
		\item Heirarchical Inheritance : 1 Base Class --> 2 or more Child Classes. 
		\item Hybrid Inhertiance : Any legal combination of any of these things. 
	\end{enumerate}
}

\subsection{What Access modifiers mean when inheriting}
\begin{enumerate}
	\item If you do class child : private parent; then every private data member becomes inaccessible, coz anyway thats what should happen, then the protected data members become private, and public data members also become private. 
	\item If you do class child : protected parent; then its the same thing, except you still cant access private variables, but protected and public data members become protected
	\item Same with class child : public parent; everything remains unchanged. The objects will behave in accordance with the usual laws of objects.  
\end{enumerate}


\subsection{Constructors and Destructors in Base and Derived classes}
\begin{enumerate}
	\item Derived classes can have their own constructors and destructors
	\item When an object of a derived class is created, the base class's constructor is executed frist followed by the derived class's constructor is executed first, followed bt the derived class's constructor
	\item In case of multiple inheritances, the base classes are constructed in the order in which they appear in the declaration of the derived class. 
	\item For destructors, the order is reversed. 
\end{enumerate}

\section{Overriding Member Functions}
\begin{itemize}
\item If a base and derived class have member functions with same name, and arguements then method is said to be overridden and it is caled as "function overriding" or "method overriding". 
\item The Child class provides alternative implementation for parent class method  specific to a particular subclass type. 
\item You might need to do this if your child class has something to add to the previous definiton. You could still call it from that function. 
\item If you have multiple functions tho, you could have some ambiguity in your code, and to fix that you could the scope resolution operator.
\end{itemize}


% \lstinputlisting[language=C++]{../Programs/inheritance_ambiguity.cpp}

\section{Virtual Base Class}
\begin{itemize}
\item In hybrid inheritance child class has two direct parents which themselves have a common base class. 
\item So you can prevent mumtiple copies of the base class coming into the child class by declaring the base class as virtual when its being inherited. 
\item So like imagine you have 2 base classes each inheriting the same class. Now imagine a third class that inherits from both of them. So the base, or the grandparent classes methods are copied twice. You can prevent this by declaring them as virtual base classes. 
\end{itemize}

% \lstinputlisting[language=C++]{../Programs/virtual_base_classes.cpp}

\section{Inheritance in Java}
\begin{itemize}
	\item It is pretty Much similar to cpp
\end{itemize}

\begin{verbatim}
	Syntax: 
	class derived_class extends base_class Name
	{
		// methods and stuff. 
	}
\end{verbatim}


\section{Operator Overloading}

\begin{itemize}
	\item Operator overloading is a feature in C++ Programming that allows programmer to redefine the meaning of an existing operator when they operator on class obects. 
	\item It is the ability to tell the compiler thow to perform a cerain operation when its corresponding opeator is used on one or more ariables.
	\item Closely Related to function overloading. 
	\item Allows existing operators to be redefined or overloaded to have new meaning for a specific class objects. 
	\item Already used the + and - operator when you are adding ints and floats and stuff. They have been overloaded to implicitly convert the operands if they are compatible, but not same. 
	\item Overloading of operators are achieved by creating operaotr function. 
	\item An operator function defined the operations that the overloaded operator can perform relative to the class. 
	\item An operator function is created using the keyword Operator. 
	\item Operator functions can be either members or non members of a class. 
	\item Non member operator functions are always friend functions of the class, coz you need to access all the data members. So you gotta use the friend keyword.  
\end{itemize}

Syntax: 
\begin{verbatim}
	Returntype classname::Operator OperatorSymbol (Arguement list)
	{
		// function body. 
	}
\end{verbatim}

Restrictions on Operator Overloading

\begin{itemize}
	\item Precedence or Associativity of an operator cannot be changed by overloading. So use parenthesis to force order of overloaded operators in an expression. 
	\item C++ doesnt allow new operators to be created. 
	\item Number of operands an operator takes cannot be changed, unary remain unary and stuff. 
	\item Cannot overload the meaning of operators if all arguments are primitie data types. 
	\item So that means no overloading for operators for built in types
	\item You cant change how 2 integers are added. 
	\item You cant change ::, ., .*
	\item .
\end{itemize}

\subsection{Types of Polymorphism}

\begin{enumerate}
	\item Early Binding or Compile Time Polymorphism
	\begin{itemize}
		\item Events occur at the compile time, so the compiler while making the exe file, knows what function to call. 
		\item All information needed to call a function is known at compile time. 
		\item It is therefore efficient. 
		\item It is also fast in execution because of this.
		\item To Invoke it you have to overload your functions or operators. 
	\end{itemize}
	\item Dynamic Binding or Runtime Polymorphism
	\begin{itemize}
		\item Events occur at runtime
		\item The OS Decided what function to call
		\item The Information needed to call the function is known at runtime. It is fleixble. 
		\item Due to all these factors, its slow. 
		\item To invoke it, you need to use the virtual keyword, or override your function in java. 
		\item You always need to use pointers for this. 
	\end{itemize}
\end{enumerate}

% \lstinputlisting[language=C++]{../Programs/virtual_base_classes.cpp}

\subsection{Pure Virtual Functions}
\begin{enumerate}
	\item These are called Abstract functions. 
	\item They dont do anything. 
	\item You assign them to 0
\end{enumerate}


\subsection{Abstract Class}
\begin{enumerate}
	\item Abstract Class is also known as abstract base class. 
	\item An Abstract class is a class whose instances or objects cant be made. 
	\item Objects of subclass can be made if they are not abstract. 
	\item An Abstract class has atleast one abstract function (Pure virtual function )
	\item Abstract class can have normal functions and variables along with a pure vritual function. 
	\item If even one pure virtual function is not overridden, the derived class will also be abstract. 
	\item Compiler will refuse to create any objects of the class. 
	\item You cannot call a construcuter in this. 
\end{enumerate}

\subsection{Virtual Destructor}
\begin{enumerate}
	\item Calling the destructor of base class does not destruct the memory of derived class. 
	\item This problem can be fixed by making the base class destructor virtual. 
	\item we can ensure that the drived class destructor is called this way. 
\end{enumerate}

\end{document}

